<html>
<head>
<base href="https://websim.ai/cube-visualizer/">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>yaudr bossfight</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
  body { margin: 0; overflow: hidden; }
  canvas { display: block; }
  #audioControl {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
  }
  #hpBarContainer {
    position: absolute;
    top: 10px;
    left: 10px;
    width: 200px;
    height: 20px;
    background-color: #333;
    border: 1px solid #fff;
  }
  #hpBar {
    width: 100%;
    height: 100%;
    background-color: #f00;
  }
  #hpText {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    text-align: center;
    color: #fff;
    font-family: 'Tw Cen MT Condensed', sans-serif;
  }
  #bossName {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-family: 'Tw Cen MT Condensed', sans-serif;
    font-size: 48px;
    color: #fff;
    pointer-events: none;
  }
  #cooldownIndicator {
    margin-top: 10px;
    color: #fff;
    font-family: 'Tw Cen MT Condensed', sans-serif;
  }
</style>
</head>
<body>
<div id="audioControl">
  <button id="playPause">Play/Pause</button>
  <input type="range" id="volumeControl" min="0" max="1" step="0.1" value="0.5">
  <button id="toggleUI">Hide UI</button>
  <div id="cooldownIndicator">Cooldown: Ready</div>
  <div id="dashCooldown">Dash: Ready</div>
</div>
<div id="hpBarContainer">
  <div id="hpBar"></div>
  <div id="hpText">YAUDR: 1000 HP</div>
</div>
<div id="bossName">YAUDR</div>
<script>
  let scene, camera, renderer, cube, edges;
  let audioContext, analyser, dataArray;
  let isPlaying = false;
  let audio = new Audio('song.mp3');
  let additionalShapes = [];
  let fallingWireframes = [];
  let gainNode;
  let lastDropTime = 0;
  let delayReductionTime = 0;
  let smallTexts = [];
  let bossHP = 1000;
  let playerHP = 400;
  let thrownObjects = [];
  let raycaster, mouse;
  let lastShootTime = 0;
  let shootCooldown = 1000; // 1 second cooldown
  let lastBossAttackTime = 0;
  let bossAttackCooldown = 3000; // 3 seconds cooldown
  let lastDashTime = 0;
  let dashCooldown = 3000; // 3 seconds cooldown
  let isSpamming = false;
  let spamEndTime = 0;

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function onMouseMove(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  }

  function onMouseClick(event) {
    if (analyser && Date.now() - lastShootTime > shootCooldown) {
      raycaster.setFromCamera(mouse, camera);
      throwObjectInDirection(raycaster.ray.direction);
      lastShootTime = Date.now();
    }
  }

  function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const geometry = new THREE.BoxGeometry();
    const material = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
    cube = new THREE.Mesh(geometry, material);
    scene.add(cube);

    camera.position.z = 5;

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    window.addEventListener('resize', onWindowResize, false);
    window.addEventListener('mousemove', onMouseMove, false);
    window.addEventListener('click', onMouseClick, false);
    window.addEventListener('keydown', onKeyDown, false);

    setupAudio();
    audio.play();
    isPlaying = true;
  }

  function onKeyDown(event) {
    if (event.key === 'e' || event.key === 'E') {
      if (!isSpamming) {
        isSpamming = true;
        spamEndTime = Date.now() + 2500;
      } else {
        dash();
      }
    }
  }

  function throwObjectInDirection(direction) {
    const geometries = [
      new THREE.SphereGeometry(0.2, 32, 32),
      new THREE.BoxGeometry(0.3, 0.3, 0.3),
      new THREE.ConeGeometry(0.2, 0.4, 32),
      new THREE.TorusGeometry(0.2, 0.1, 16, 100)
    ];
    const geometry = geometries[Math.floor(Math.random() * geometries.length)];
    const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const object = new THREE.Mesh(geometry, material);
    
    object.position.set(camera.position.x, camera.position.y, camera.position.z);
    object.velocity = direction.normalize().multiplyScalar(0.2);
    object.isPlayerBullet = true;
    
    scene.add(object);
    thrownObjects.push(object);
  }

  function updateThrownObjects() {
    thrownObjects.forEach((object, index) => {
      object.position.add(object.velocity);
      
      if (object.position.distanceTo(cube.position) < 0.5) {
        if (object.isPlayerBullet) {
          bossHP -= 10;
          updateHPBar();
          scene.remove(object);
          thrownObjects.splice(index, 1);
        } else {
          object.velocity.reflect(new THREE.Vector3().subVectors(object.position, cube.position).normalize());
          object.isPlayerBullet = true;
        }
      }
      
      additionalShapes.forEach((shape, shapeIndex) => {
        if (object.position.distanceTo(shape.mesh.position) < 0.5) {
          if (object.isPlayerBullet) {
            bossHP -= 5;
            updateHPBar();
            scene.remove(shape.mesh);
            additionalShapes.splice(shapeIndex, 1);
            scene.remove(object);
            thrownObjects.splice(index, 1);
          } else {
            object.velocity.reflect(new THREE.Vector3().subVectors(object.position, shape.mesh.position).normalize());
            object.isPlayerBullet = true;
          }
        }
      });
      
      if (object.position.distanceTo(camera.position) > 50) {
        scene.remove(object);
        thrownObjects.splice(index, 1);
      }
    });
  }

  function updateHPBar() {
    const hpBar = document.getElementById('hpBar');
    const hpText = document.getElementById('hpText');
    if (hpBar && hpText) {
      hpBar.style.width = `${(bossHP / 1000) * 100}%`;
      hpText.textContent = `YAUDR: ${bossHP} HP`;
      if (bossHP <= 0) {
        explodeWireframes();
        alert('You defeated the boss!');
        bossHP = 1000;
      }
    }
  }

  function explodeWireframes() {
    const lines = [];
    fallingWireframes.forEach(wireframe => {
      for (let i = 0; i < 10; i++) {
        const geometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(
            (Math.random() - 0.5) * 2,
            (Math.random() - 0.5) * 2,
            (Math.random() - 0.5) * 2
          )
        ]);
        const material = new THREE.LineBasicMaterial({ color: 0xffffff });
        const line = new THREE.Line(geometry, material);
        line.position.copy(wireframe.position);
        line.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 0.1,
          (Math.random() - 0.5) * 0.1
        );
        scene.add(line);
        lines.push(line);
      }
      scene.remove(wireframe);
    });
    fallingWireframes = lines;
  }

  function updateSmallTexts() {
    smallTexts.forEach((text, index) => {
      text.position.y += 0.01; // Move up slowly
      text.material.opacity -= 0.01; // Fade out
      if (text.material.opacity <= 0) {
        scene.remove(text);
        smallTexts.splice(index, 1);
      }
    });
  }

  function dash() {
    if (Date.now() - lastDashTime < dashCooldown) return;
    lastDashTime = Date.now();
    camera.position.x += (Math.random() - 0.5) * 2; // Random dash
    camera.position.y += (Math.random() - 0.5) * 2;
    document.getElementById('dashCooldown').textContent = 'Dash: Used';
    
    setTimeout(() => {
      document.getElementById('dashCooldown').textContent = 'Dash: Ready';
    }, dashCooldown);
  }

  function setupAudio() {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    gainNode = audioContext.createGain();
    
    audio.src = 'song.mp3';
    const source = audioContext.createMediaElementSource(audio);
    source.connect(gainNode);
    gainNode.connect(analyser);
    analyser.connect(audioContext.destination);
    
    analyser.fftSize = 2048;
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    
    audio.addEventListener('play', function() {
      audioContext.resume().then(() => {
        console.log('Playback resumed successfully');
      });
    });
    
    document.getElementById('playPause').addEventListener('click', () => {
      if (isPlaying) {
        audio.pause();
        document.getElementById('playPause').innerText = 'Play';
      } else {
        audio.play();
        document.getElementById('playPause').innerText = 'Pause';
      }
      isPlaying = !isPlaying;
    });
    
    document.getElementById('volumeControl').addEventListener('input', (event) => {
      gainNode.gain.value = event.target.value;
    });
  }

  function animate() {
    requestAnimationFrame(animate);
    if (audio && isPlaying) {
      analyser.getByteFrequencyData(dataArray);
    }
    
    updateThrownObjects();
    updateSmallTexts();
    updateFallingWireframes();

    if (Date.now() - lastBossAttackTime > bossAttackCooldown) {
      launchBossAttack();
      lastBossAttackTime = Date.now();
    }

    if (isSpamming && Date.now() > spamEndTime) {
      isSpamming = false;
      document.getElementById('cooldownIndicator').innerText = 'Cooldown: Ready';
    } else {
      document.getElementById('cooldownIndicator').innerText = 'Cooldown: Active';
    }

    renderer.render(scene, camera);
  }

  function launchBossAttack() {
    // Boss attacks the player
    if (playerHP > 0) {
      playerHP -= 20; // Decrease player HP by 20
      alert(`Boss attacked! Player HP: ${playerHP}`);
      if (playerHP <= 0) {
        alert('You have been defeated by YAUDR!');
        // Reset or end game logic here
      }
    }
  }

  function updateFallingWireframes() {
    // Logic to update falling wireframes goes here
    fallingWireframes.forEach(wireframe => {
      wireframe.position.y -= 0.01; // Fall down slowly
      if (wireframe.position.y < -5) {
        scene.remove(wireframe);
      }
    });
  }

  init();
  animate();
</script>
</body>
</html>

